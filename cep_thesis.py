# -*- coding: utf-8 -*-
"""Copy of cep_thesis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/tmorshed/dbs_cep/blob/master/cep_thesis.ipynb

# Analyzing cortical evoked potentials (cEPs) in STN-DBS
#### by Taha Morshedzadeh. **Krembil Research Institute, UHN. Toronto, Canada**

*This work is done as a part of the HMB496 "Independent Project in Human Biology" i.e. undergraduate thesis at the University of Toronto during Fall-Winter semesters of the 2019-20 year.*




In this Jupyter, we will try to estimate the cortical evoked potentials using EEG as a result of Deep Brain Stimulation in the Subthalamic Nucleus (STN). We will use the package `mne` from the Martinos Centre found at [this link](https://mne.tools). This package automatically sets matplotlib to `Qt` but since we are on Colab and it does not yet support `Qt`, we make it `inline` so that it appears as any other normal output in the notebook below the code snippet.


![MNE](https://mne.tools/stable/_static/mne_logo.png)

![Human Biology](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbwAAABxCAMAAACZb+YzAAAAjVBMVEX////+/v4AAAAbGxv5+fnz8/P4+Pjm5uaenp7w8PDS0tLq6urt7e2pqan09PTLy8ujo6OJiYnf398VFRXZ2dnOzs6Pj4+9vb26urrDw8OZmZl1dXUsLCyvr69vb29aWlpCQkKGhoZ+fn5PT081NTVFRUViYmIlJSUQEBA8PDwqKipUVFRERERoaGhxcXH030dVAAAW40lEQVR4nO1diWKjuLIFGbNjFrMKZMxiljjk/z/vVUlgk62753ZmkrxwerptS0IIHVWpSioxkrRhw4YNGzZs2PCjIH92Azb8D5A58OOzW7LhH0OwtjH3LSFLihvIkmqoxmc3ZcM/hSxZVR5KGU2psgngd4PNdC3WndhJ3W3m+26oaOWwxo5YQrXPbsuGf4hYC2n95EVVRfXQNI1Nd34HyGhqSlYdOXFmNu7ZNeoqrpkibbrz60OWtFPu5c7kdylraEXDPDUD39gch28BJzGTRnGd6RqPRU4rdvI9L1U/u1kbfgsQL8acsKyCknRp9+BGNSv9fVBt5H15gHOexXWau/25u8aS7UiM1GFlOlUefHbbNvwWBtiZuR8T3608h1VJfikaN061eCPvGyDVA2rnhWNRKZs6lrOsPrEgP20Gy9eHETdd9eRXlZebbtrnVRaVuV5p2yrZ14c8pZruOabmVx5leXyN045Qs4zT/Wc3bcNvkVKn0/s687op1mvzUrPqep1So0o+u2UbfgNZMuqcBUcS67lee45D4rqJzdSP9W2J88tDljLHYlSfyoBaVc7oU5kkcUbNbYXl60OW5czJg8TPmO6wQHMMJ7Ucn+d8dts2/AZIkZ37fipFeqVLWSKpp/zkSJvgfRPIQRDCh26qVgw2prxXN+K+DXjskSwpsZTV+01dfivMUX+SHdtBHolIso3Ab4JF1FgcHmpdRI99BfK2UJo/w149mL6jZ1HmnxxN+Rrb6JsC+BPIEfNO41THU+/7cTz6VfAVug1m4c9uwjeAQoOUEBKoFSGTte8J8f/jFrw9VGz3P27Gd8KiG2Uvja5te41Y07axqxc9e1lUY0mWJaa4QHET183cv5ILK83cJGUsOyB18MdWn1OoBD5x/uYO/99xMDj2tuuaYRi6bmiGEXw19yLDOCz9aekFGfSZPDmMCXkM/0qz2s6RNFnqHy8unm+RTOI9LxDmO7Itr/4CjOoCngBz5i9zsp7epEuuyOl+4X5H/m7TAYiviY5NII2Fv1xCn+XL8j4n27mJ9yF76p7jsD8cDqp6YBH8wyGSbc++laWkvn2XDiX5a5tmputCMm6baIcX+WpNXiZtuEO5ayo5yiJLo8zWMte8saI61q0AJfH9SvVE/jrExUTJk6Uc6n1zGCgV2SLY3sdCHoaQPTl+fqJ1nlOnzpYQiOfkrSYldfog8iTpibyyjubWbeT9CrKgA8wFN2cKaxuaj00qs1p7k7xVJ3Py/lJtzuRdhndq2sj7JWbJg64Lnpz6xMBL9/Wp9uliKDwnb2W4H4TkGSYYG7JiWypYjJYLf4MA5inFsA5ihdTKmCYcAVNStTCwV3c3CT1YWn2NuMuiuBpfUrHMNAu45AN5ypzEEkzCYkHqsMDWLNnQLM2SFEvTrJ/pyt/VZuCfakYbPW4dryrfIa/z9MUMpSOQZ2Tl0QSbPj4/BpJJH8bAyUdyCpK4HCYX9wl1n557sEcCr22iuCvJuDL+TTIx/9qnwK60d2tiQjtUWkEDigqLCfKkg145ejX4KJ9y4nt6Sc670TZL8uBJdlqS+mfapMpNbaqs7Bza2UaR6FNuLmP5OXn9+VKWl/P53Ba7AcgzT+QC8qdR0mhSeiH9pFtRQbqT7lxICSqPkhAoOu2xZHFitpXfpRc9O2oYmk5KuEc4kkcUZWeHN4y5YasKtem0gUiCH2YPRGukoA5eXiJr6cOXWMr777GyNhVnqtOuqk5pfmLK0hsr8pSYMFkRUBW7ITgvlg2XpBY/ouLMDz5wfqz2CFdSPK3SYucHbYcFw6K7332e88xiB90vDxNQkQnvUelIyl0FuDyAqRYV5gQehZozZN0jLkph84BN0Fc28I/CnTxZor7TmZmb5k6V3gqsyfPJPV06NHz1o0HWZEGedW0wx+yxN2UUOjEERiTPHjlr2lje7ziTJyVkhJItCKjsE5EZkVxF8kAD1K2oCARNCnq+2BmCgwhJKTKtdsrX2L/6z7GSPCmo9Kr2/bpy6rtrvCIPlJh77yXjzCVvFOQVVyi27y6ckge+qO0geVDcCopfkgdltGYATor8IBnTTJ5MQA6BPKigRPKwVH+RgoKvE4QwjCAlKHK4D/uZ1D0nL/RpmiVJwrzT3UBfSx6SN0OWjJZL3sNVkFfaK/K4z43kwfXs6TS8R140k2dfUdPO5M3Gx0weSFW5c3lprW1k60qEEPK4xP1plJT6xy5/Ks4SAgEmS0pZ4maJQ12x3YDp75AHkldwyeuvYs5D8uzrBb+j2pRxXgKBiXumSuN5nvPkN8kD4WyOQHQP5MkxKkS42iAxkJMTbvRQvusQEF+W0v6YGEGXCmnzSJA4P1TuALV+h+f5eZ7X1PPoLY36NzP8kJOVhrIHYbD0EdAa9kheOPI5L9rVSDzOeWGPi5cPFyA4KCbMDNryfnNdzHlQNEdFCXMe1NFyj6Aa0Yo9o+RZrZj0Ym50gkcxUXPey4r6PNZ+qtbEReHfYJpVqIwmymrZ/0C42qSk1jRvOjamDaw9Yk5GKix/gnyzz8EzI22oAY/C2nxYWZsnUWFKuL9POjzY4pBaRnsFVAJMbUTkP0lodFIeFMEembIEt1iNsFx+KBqyO+6KOqpPUdzujscd/O1bljXUzQvIGm7zn3stijZeJpi0Kdqrq8Ak1RdTJjXjZKbnou0yyWsfxthWTkVx8YKub06Zfryy9Hq+5KEEH01si/4O6qIoplPXlc4ezaW+ndDHMMumnkpU0M5lHJsY1LbZXfLpmuFFWY8Wi7zYl3nxY2c8CckruloLWGSmgaWX4/E4lpkWhU4Iv/OmJzfyLM0w7GBRopq1V62AW5OYZEH3WzYk2ZBjGJaiYGlLVgPoexk6GB3Hw0GGcrKtCrExNGNvWJqG6wEy/3U4cHW4x4vgm6Yqsq3x7XUjmEmKxkanVGeueMvdj/XxOBry6MWWa0ZRmNlpPJGhjE0ts3Utig60eriR945yWgybe0DFs9z5H1l6lvkiom8VJSrPWfK6yC0N/6WzOg951tOPPnndkLMeBxj6EJgBizsyXCszNIG8MDJoDeTNPp88v49zhiwtPcz/m1/UuQTvznn8z5I1B6rcqZoLzO/wkZdXRt7qmdPme873zvIgdE0zhclUwkAJ6Yc66BwdOVM/MgF38tzItD3NdMM1eV8DWTcrAtYhnXH0uc35ZExAXmwnjKUsBbXJyQsDlsSpkykxkFd9qYGtz+SpNXp6YWf9pvz/b0yoNsE7zydGU4eTB7x5ztVn1KV1/zwo6NPB5qgnj3uUev2z92opSN50in1K/TiffG6wTDWNvTiGz6r4YoGTRk4eTlVzdTC2jJIfu6wpEJBje3k8j9dyPD9ezrvdrj9fzuN4vYzny2Nx7M3PbuFzKBk4CmK3MYu9H7y6grDAKUcMA//Y7Z7/PrZfM8JAfuY+/FSoJdndMQBnwNpwSyDT/1jvW536B2lvFJFffF8cir9l7rVD+mdFV4m/u/+/PrLYjTyQu2uVaVYYT1wEOXnCPpBvmH/Of9e+9a07787e4p2tLlsSF39OunmHt4ybayitc26dcfMbF3fx1QBYOYnSzZWUXv4vI24+5n0RYHXZkr9OedGy2x2WZ39Z9M30D0VYCKKOpKj1BP0my7NPM6NHotx74AXeXVF5Weq9tZn19xdK8Nn6ynstl39T4I3++jMBk9c/XrTmjdpXhL0q8weP8TcwBFGk9/RANnFzTGU2LYXmxMMJM3lhmiXMiUO0GRLXTTNZoixL5wetT5Q5bC+5Dp4eSrKDrcMXN3P53lyaRFFmqczJMjfLsiRxMLRl72RRptdPvqnc+sv0pzox+bsNWOa6SQK30WoGn1hbkrDKkswUv7MQD1okLgtfPZJGn56qcG555DB+Vzej6ZoES9QaYa1OLtJUluf5fDhDdhk8ZZznTrDqedPPcxqKxgY0S+evYVk5zAskOY2TJIFKoeUJnTc8AvqU+/+K3SdL2Q5Ej9QJxqfsHVUybDfI3Aduu/ThvVhNCDlX+CTpiZAyA3OvHMiFbxHIQTqSKVMltz5DsdyxFVZi+ZiTF7dkaEzZheseuqmbSpIfoKv0kZAxrhsyzLExwdjSLC+ID3V68EmKiilSTS5lCdUeS/yIJBO8T3KEYSSb/rB7dQrUvLSn+ulMerFzFPrQjrKbrgXu5S6PI0unAWptoaIr1opBh1bVd3UOza7xmWQTH/gUTw+knBdQlay/5DUkjBGqoj04UiQVMalRDaPfkuyiaMpyB49VlteixX4zG2xOS47s400/uHMNojfkDDcHDiGMPkUyA7NB0Rti5TaNSVJFbgeu6k7lcw8klYHI1YnompCQeRzTYfBmzaEf+X6O1s8B83HM1SmUBdqwFr7MpV0KbITW8J14iQ0DRmhbFzw5YT7wYMBDhdsIYUMKHqAbFq8OX2akwrhewz8SX0j0RBpMscr7YpEsKS2vtRUhhjnUGlwaLh7sTERoh5ST1sYRRTq+l6JSwnftg5zsHF612R+PjlgnCFpsazphD/kEd6jhcaC+tK9xl9LydyT+8IVGGbc/UUHWmgbNUA+JK8mKGnC9ycPbbxZHTMjyGkA68W8yJQPJhengiOBm6XAkupjVg4J0tpivny68omA3B60klFsq4REDiaSgF+dwE8IXLKU45zdlw5Hn8hh7sxBHlCIe+pfNIyQeX05I2jhaPG0PIiT+5x5P5MqPkGX+qiTGf0CXP5IaBSJykSoRYSh5BHeTsR3kghfGZOAKyCTiKSSjJw+c3uBMhgdzJi+BhMQU1xV8MILCVclZE2EdHdllH86dQdMJ2AMt2Z5CKTRd3j7twnWpE6+eNyb9YVZRtDM4Y974SOZ5kR3nYg983QMbDApLtDfaiW7k5GH/KMpCHjJjXwnfXk/JqGJdmlBT6ZGTJ3YfwhZ6dPmBcj44WK8pHuLOiS/uAElRSyb+SpknPP+HTVJWkie8DbvBtVtOWTKUs2TsJ9JjeyVKMLgD7HHCb3PhgwGvTHHs4POcm4E88NkVyVtaopPWnC21al5exLAsDKn6UMiSTiULdeTxmMW6nNI4wBZ4qEobVapXq2Mx71sOKhSJpF/3MO+dcI5g/ZxX3KI79z0psR8P+TRP3TuhNgNH3BtEDslze3GJ+0CumSYtnQCTcXpjBsh7dkpeJ31it6+Wx0AP3gyYCopg/pPgIExf259GQ+bheXjC82vCOMu4xsV78AsrDAdHab8ss4Z8JQRzgiLUdwSDp4C8u1w5SN7c6v6WXBPy0Qfs91NmZQn6dQ+XnRsVJzA6VS7kR2JmFnu6P+8b5NEGumvgHcCKOe9OHs6SqHcCEMCFPLq3rX3OXX9OXoqxuqThk7k6gRYub0/r9mvyxvXhQEjsSZM3+5fkJeROHhtQCjl5gaLu8/K1vX4nzyqJN8/vklKQJ5RCIO8gKelRTHUej8oX0AmPKA5gys0JcvsmeTCij3fyoGkfvcifeWnM6h33DJqnti9P3dUEWwOU5tH3PJrdzy6vyNMX8mAWSI7DzlmR1y7kgaro+bHJei4N5B3789gKK4GTN5y7ctxV8xqlPRG0R+dIa3f3Lnm87uOQvZIlRm5x2lLYL8f/du3j2OJi0Rvk0Vv9+s1heSRXbDFId9NdH8aEz+Yn0mir25gzecYTGUA9v0GejOGPd/KsjycvBodKyrKO8MWx4447AT7BCS/NJCdVvNu7iv2V5KHBAhqRYhxfCBazJ7FxzmvvkodHU0IQvEVdoOSpsmJ1T/Nv6N6wQ3uCl8YnpGhoiwrCYnimNl+Eq+ikeL0hlBJy045BL8JCT6QLrcBt6teOMpCnz01pSHdzN0+EG2Q6XAjiGwtrO+b6UVQBo3KRPK4PHwxtnFmS5ZXaBJvrdqRx/+HkWczydCcF1SW88mPhR2bWA4lg9DInUVZBt9XSW/Ag3EYD84CroqgB9thlfrCV2sQuqeRTvXTabc6bXYhwB2Vhmurs+bHRlklLwg8KSVF//AV5MpgFrz0nMEqn2916mPM4FU9IhZm8KXkzefsTOQuFC83oSCzmvCcVlNBsc4OFq9+CMY7c8BbkydVAmuRylzzvpjbh2fLFQdiT4YPnPMWzadahw004e6QO0j34MXh+SzLBC1C9FXnD0pBcRDoL8sD6Goaibtbkia+gMUmT3X0xtDa5FaaIcLKQOyMwcvnwVEwxhUFtvCPcX5KHXfSaPK1B21wgOp4DYW3m+1WUzBp3tYkOAZsbLY1i/OkYBgzeBL6sAmxgmNwWoWbgNchC8jCnIcO1WMhDK3WRPKh/XEKkLNJ+dJiizmji685eygpgbzhpiQbckTGUDAfybO1ubsYiNhYX0Lh7Bhz4nfABU2D7Mhe7SR5mBMNxuIdIz34ePj1312ZXoRMVS57Oq4e+4HRzV2Ehz2x5KO8KHine8HphNvJnTiusXMajYfzgzFvrs8DM4rmDL97M/ZxxUUUS8NMtkHw+EJdj3YcGVxWg/b04GBCU5Eju5MU38tbNeffk/f8Om2q+mzGaWe5l2A1goIDWGrpQy2JP9xI3Xo4hoysz21t2PlsgcnXeiwkhKUgrhjYM0Dvf+MSDKS2LNCBpfKCr2ci4nydUEm6P49NmQ4K9nPbCLpyddEksevbLOutcMRoDhzfWe2GIYZyudPB6IVRqwx2sNxeNkRhV/ILRSxr+VqBoxNAYSKlwaUZGh7HCdtknmMHwwY1qJybWaFEydkfIXW36hI86fkdQqbGFaxfO4L0ePH8HWXL12PVs5vguDO5d8TiA3PVa4jO9dqhXR8tT45tUCZlC2zanZaMoLKFlIoQWVAVPMih47Stn1CSNcVukgdn/6mpaEIv5HsdljTG12pVbcuDvxYFtjvwkmQIagOizSaLYDiGjaa/ajXoueMWJzH2wU2gbFQ+bF7T3mXELIVwVVWww+RvTWFpHSJvadta3fOkNWReMpETMjMGFDFVgBDXxeHWGRx5Dgw9ZMI4Wg2WvneCxtNmLAY+fTKahUeHWfzBkNza9zGGMUedKcPOclCw2ndrUdTvObr0Dd1bYOPRFUTSuSEza83k8i0GmVjtIUZ4u58fHsclv2n0/0mX+M+qiHc+X5nJud6iIjKkYL+3I4OpDPbT13rxc+r5oJzTq5LI5P57Hhk90sn8+ny+P5+5uXjpXrCx/GT2G62KsIX3blq4wHpO2PY/j6L2iGdRbC429XK7zT9k8HY9Fe9Et8bCPBbg1XGjdhlxxBXqvF+ShhQbyYaFdz4/jZRJMu7vZpzIeod3QB8ubGg7sAp3Wlpn6Wkt8ALQ4pUma+mGaxf0wtF4Kusw9pWFCX0XWGVqgvTQTxACX3gnkUm+Nlg/PWy9zJ0QVrogcMIP7CtbCtbT6fP3Yey6Fytv9cVi9H2Le4HlrSf/1xbKl3bSGwi8xxIWWm4kve+2daMNfiNVB0/4N3ub7Mj+TdE1SdRkUm2s50M7M1VeHm/+i7g+oY8P7AJ2nMYrTi3NQIlMy8U1gacxeidi/24p/J1Dgg/BvxTH8NXizlKxMDw63vd3I0KeP3r74g2b853f8J/ii3CEwVCEzWcWPWEXUMZP0a4b8bXgLWYqbeNy+jfCEKt3eD/xtADaLK0W6grpdpYHqPulfXI9tuEFOTBd88tiJPfD3at21vN9ftOFrQE4DKUySOskTk7q5J1mb5H0bIHnUSzuXxjRkeSwZP/ktC98NEQtAZ7K6Ss3KjJ3M2wyW7wM5ZPhC/jA08V8MBf7Cns2GNX4djL/hS+P2Wod5HfjfO9eyYcOGDRs2bNiwYcOGDRs2bNiwYcOGDRs2bNiwYcOGDRs2bNiwYcOGr4X/Aynno6W0Tpt1AAAAAElFTkSuQmCC)
"""

!pip install mne

from google.colab import drive
drive.mount('/content/drive')

"""### a) import packages and files:"""

# Commented out IPython magic to ensure Python compatibility.
#import os
    
# %reset -sf

import numpy as np
import mne
import matplotlib.pyplot as plt
import scipy.signal as sg
from datetime import datetime

# %matplotlib inline

raw = mne.io.read_raw_cnt(r"/content/drive/My Drive/research/nsbspl/data/130Hz_STN_OFF_LeftSTIM.cnt", preload=False)
#preload=True makes it load to RAM as well. Normally, it only loads the symlinks to the RAM and the data stays in the local storage

##Choose channel to analyze                                                     #Please input the desired channel name
ch_choice = ['L2']
#Choose the times below. We will crop the file in this  window.
time_secs = raw.times
start_stop_seconds = np.array([time_secs[0], time_secs[-1]])                                #Please select start and end crop times in seconds
dpi = 50

##Import metadata to internal variables
n_time_samps = raw.n_times
time_secs = raw.times
ch_names = raw.ch_names
n_chan = len(ch_names)
sampling_rate= raw.info['sfreq']
dt=1/sampling_rate

#finds the index for the chosen channel
ranger=np.arange(1,n_chan);
for i in ranger:
  if ch_names[i]==ch_choice[0]:
       index_channel=i
  else:
       pass

## Print some metadata
print('the imported data object has {} time samples and {} channels.'
''.format(n_time_samps, n_chan))
print('The last time sample is at {} seconds.'.format(time_secs[-1]))
print()  # insert a blank line in the output
print('sampling frequency is {}'.format(sampling_rate, 'Hz'))           
print('MISC INFO: {}'.format(raw.info['description'], '\n')) #misc  info

print(raw.info)
print() #adding an extra row 
print() 
print()
print()

print('The sensor locations on the cranium:')
raw.plot_sensors(show_names=True);
print('The sensor locations in 3D:')
raw.plot_sensors('3d');

"""## Crop the time window and load to RAM:"""

#Cropping the file based on the times provided in cell4, line5.
raw_select = raw.copy().load_data()
raw_select.crop(tmin=start_stop_seconds[0], tmax=start_stop_seconds[1], include_tmax=True);
raw_select.pick_channels(ch_choice);
#start_sample, stop_sample = (start_stop_seconds * sampling_rate).astype(int)
times=np.arange(start_stop_seconds[0],start_stop_seconds[1],dt)

#extracting some internal variables from above input
duration_selection = start_stop_seconds[1]-start_stop_seconds[0]
start_sample, stop_sample = (start_stop_seconds * sampling_rate).astype(int)
times=np.arange(start_stop_seconds[0],start_stop_seconds[1],dt)
lsel=len(times)
times=times.reshape(1,lsel)

#printing some metadata
print('We will use the timewindow of {} to {} seconds.'.format(start_stop_seconds[0],start_stop_seconds[1]))
print('this is equal to {} milliseconds in length'.format(duration_selection*1000))
print('this is equal to {} datapoints in length'.format(lsel))

#imports the selected window to a NumPy Array
raw_selection = list(raw[index_channel, start_sample:stop_sample]);
x = raw_selection[1].reshape(lsel,);
y = raw_selection[0].T;
y = np.mean(y) - y
y = y.reshape(lsel,)
#print('Quality control:')
#print(x.shape)
#print(y.shape)

## Setting the matplotlib variables:                                            # Modify the matplotlib vars which will be used throughout the notebook
if duration_selection <= 10:
  figwid = duration_selection*10
else:
    figwid=100

fig = plt.figure(dpi=dpi);
axes=fig.add_axes([0, 0, figwid, 1]);
axes.plot(x, y, c='k');
axes.set_facecolor('white')
axes.set_title('imported time window')
axes.set_ylabel('LFP (mV), mean = 0')
axes.set_xlabel('time (seconds)')
axes.autoscale_view(tight=True)

"""## Find the peaks:"""

amp_max=max(y)
amp_th=amp_max/2
print(amp_max)
print(amp_th)

pkfinder=sg.find_peaks(y, height=(amp_th))
pkpt=pkfinder[0]

indx_pks, pks = pkfinder[0]*dt+start_stop_seconds[0], pkfinder[1]['peak_heights']
lstim=len(indx_pks)

# x must be the indx_pks array when time is defined in seconds
def stim_avg_freq(x):
  x1 = np.insert(x,0,0)
  x1 = np.delete(x1,-1)
  dist = x - x1
  return 1/np.mean(dist)

def stim_max_dist(x):
  x1 = np.insert(x,0,0)
  x1 = np.delete(x1,-1)
  dist = x - x1
  return np.max(dist)

stim_max_dist = stim_max_dist(indx_pks)

stim_avg_freq=stim_avg_freq(indx_pks)

print()
print('Average stimulation frequency in the imported window is {} Hz'.format(
    stim_avg_freq
))
print()

print('Maximum distance between the stimulations is {} datapoints'.format(
    stim_max_dist*sampling_rate
))


print('Mean distance between the stimulations is {} datapoints'.format(
    stim_max_dist*sampling_rate
))


print()
#print(indx_pks.shape) #Quality Check
#print(pks.shape)
#print()
#print(indx_pks)
#print()
#print(pks)


##Change events into MNE format, will be stored in i, for possible use           #uncomment for use:
#sp_data = pkfinder[0].reshape(1,len(indx_pks)) #i = np.append(
    #pkfinder[0].reshape(len(indx_pks),1), np.zeros((len(indx_pks),2), int),
    #axis=1)
#print(sp_data.shape)


fig1 = plt.figure(dpi=dpi);
#plt.savefig(fname='/content/drive/My Drive/research/nsbspl/figures/cep/{}_selected_window.png'.format(datetime.now()))
axes=fig1.add_axes([0, 0, figwid, 1]);
axes.plot(x, y, c='k');
axes.scatter(indx_pks, pks, marker='x', c='maroon');
axes.set_title('detected peaks');
axes.set_facecolor('white');
axes.set_ylabel('LFP in mV, mean = 0');
axes.set_xlabel('time, in seconds');
axes.autoscale_view(tight=True, scalex=True, scaley=True);
plt.show()

## Making an MNE stim channel out of the found peaks

"""

Uncomment to use. in this notebook, we will just use the numpy array and
manipulate it using numpy,scipy,etc.

""";

#stim_data = np.zeros((1, lsel+1))[0]
#print(stim_data)

#for j in range(1,lstim):
#  stim_data[pkfinder[0][j]] = pks[j]
#stim_data=stim_data.reshape(1,lsel+1)

#print() #1-line gap
#print(stim_data.shape)   # Quality Control
#print(len(indx_pks))    # Quality Control
#print(len(pkfinder[0])) # Quality Control

#stim_info = mne.create_info(['STI'], sfreq=sampling_rate)
#stim_raw = mne.io.RawArray(stim_data, stim_info)
#raw_select.add_channels([stim_raw], force_update_info=True)
#raw_select.set_channel_types({'STI':'stim'})

##Cutter: cuts the templates into a (epoch number * amplitude) matrix 

temp_len = int(stim_max_dist*sampling_rate) # length of each template (in datapoints)
temp_times = (np.arange(0,temp_len)*dt)
shift_left = 8                                                                   # set the number of datapoints you want the template to be shifted to left

print()
print('the length of template is {} datapoints equivalent to {} milliseconds'.format(
    temp_len, stim_max_dist*1e3))
print()

def cutter(x):
  eps = np.zeros((lstim,temp_len),dtype=float)
  for i in range(lstim-1):
    diff = pkpt[i+1]-pkpt[i]
    eps[i,0:diff]=x[pkpt[i]-shift_left:pkpt[i]+diff-shift_left]
  return eps

eps = cutter(y)

# Plotting all the epochs:
fig_eps = plt.figure(dpi=dpi);
axes_eps=fig_eps.add_axes([0, 0, 8, 4]);
for i in range(len(eps)-1):
  axes_eps.plot(temp_times, eps[i]);

axes_eps.set_title('all the epochs')
axes_eps.set_facecolor('white')
axes_eps.set_ylabel('LFP in mV, mean = 0')
axes_eps.set_xlabel('time in seconds')
axes_eps.autoscale_view(tight=True, scalex=True, scaley=True)
fig_eps.show(warn=False)

#average all the windows to build a 

avg_temp = np.sum(eps, axis=0)/lstim


fig_avg = plt.figure(dpi=dpi)
axes_avg = fig_avg.add_axes([0,0,8,4])
for i in range(len(eps)-1):
  alleps, = axes_avg.plot(temp_times, eps[i], linewidth=0.03)
avgline, = axes_avg.plot(temp_times, avg_tmp, c='r', label='average epoch')
axes_avg.set_title('average epoch, all epochs superimposed [behind] and the grand average [front]')
axes_avg.set_facecolor('white')
axes_avg.set_ylabel('LFP in mV, mean = 0')
axes_avg.set_xlabel('time in seconds')
axes_avg.autoscale_view(tight=True, scalex=True, scaley=True)
axes_avg.legend(loc=0, fontsize='x-large')

fig_avg.show()

"""## Plot the Power Spectrum after stimulation:"""

raw2 = raw.copy().load_data() #.pick_channels(ch_choice);

filter_params = mne.filter.create_filter(raw2._data[0],
  sfreq=sampling_rate, fir_window='hann', l_freq=0, h_freq=80, method='fir');
filterfigsize = [0,0,2,1]
mne.viz.plot_filter(filter_params, sampling_rate, flim=(50, 160));

print('this is the shape of an ideal filter to remove the {} Hz artifact and beyond'
.format(freq[3]))
print()

freq = [0, 10, stim_avg_freq-30, stim_avg_freq] #starts the fir 30 Hz before the stim frequency
gain = [1, 1, 1, 0]                                                                                       #   <<==  choose FIR filter params here

mne.viz.plot_ideal_filter(freq, gain, flim=(50, 200), title='ideal FIR filter for removing the stim frequency ({} Hz)'.format(round(stim_avg_freq,2)));

fig_psd = plt.figure(dpi=dpi*2);
axes_psd = fig_psd.add_axes([0,0,2,1])


"""in the STN-OFF file, the L1 channel is very low freq. activity.
It might have had bad wiring/connectivity.""";

picks_psd = ['L2', 'L3', 'R1', 'R2', 'R3']
raw.plot_psd(ax=axes_psd, fmax= 100, color='k', estimate='power', n_fft=2048,
             picks=picks_psd, average=True);
axes.legend()

